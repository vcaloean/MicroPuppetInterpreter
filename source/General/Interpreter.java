package General;

import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;

import AST.*;
import Environment.*;
import ANTLR.*;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.util.Map;
import java.util.Map.Entry;
import java.util.HashMap;
import java.util.Iterator;

public class Interpreter {
  private ValueFactory valueFactoryObject = new ValueFactory();
  private Map<String, Resource> resourceMap = new HashMap<String, Resource>();
  private Map<KeyPair, AstValue<?>> store = new HashMap<KeyPair, AstValue<?>>();              /* sigma */
  private Map<String, Definition> definitionEnvironment = new HashMap<String, Definition>();  /* kappa */
  private String catalog = "";                                                                /* v_c   */
  private Scope currentScope;                                                                 /* alpha */

  public static void main(String[] args) {
    if (args.length != 1) {
      System.err.println("Incorrect number of arguments");
      System.exit(1);
    }

    Interpreter interpreterObject = new Interpreter();

    ParseTree antlrTree = interpreterObject.importAntlrTree(args[0]);
    Ast astTree = interpreterObject.beginWalkOfParseTree(antlrTree);
    interpreterObject.printAstTree(astTree);
    astTree = interpreterObject.smallStepEval(astTree);
    interpreterObject.outputCatalog(args[0]);
  }

  //========================================================================================
  // ANTLR To AST
  //========================================================================================

  /**
   * This is used as the bridge between ANTLR and the interpreter.
   * 
   * @param   filename  The path of the file
   * @return  The generated Parse Tree
   */
  private ParseTree importAntlrTree(String filename) {
    File inputFile = new File(filename);

    /* setup input stream */
    FileInputStream inputStreamFromFile = null;
    try {
      inputStreamFromFile = new FileInputStream(inputFile);
    } catch (Exception e) {
      System.err.println("Incorrect filename");
      System.exit(1);
    }

    /* read in example file */
    ANTLRInputStream inputStreamFromANTLR = null;
    try {
      inputStreamFromANTLR = new ANTLRInputStream(inputStreamFromFile);
    } catch (Exception e) {
      System.err.println("Error in writing from file");
      System.exit(1);
    }

    PuppetGrammarParser parser = null;

    try {
      /* use lexer, tokens, and parser generated by ANTLR to create a tree */
      PuppetGrammarLexer lexer = new PuppetGrammarLexer(inputStreamFromANTLR);
      CommonTokenStream tokens = new CommonTokenStream(lexer);
      parser = new PuppetGrammarParser(tokens);
    } catch (Exception e) {
      System.err.println("Something went wrong with ANTLR");
      System.exit(1);
    }

    return parser.puppetProgram(); /* this is the parse tree */
  }

  /**
   * Uses a walker-loader to generate the AST from the Parse Tree.
   * 
   * @param   tree  The Parse Tree
   * @return  The resulting AST top node from converting the Parser Tree
   */
  private Ast beginWalkOfParseTree(ParseTree tree) {
    ParseTreeWalker walker = new ParseTreeWalker();
    PuppetGrammarLoader loader = new PuppetGrammarLoader();
    walker.walk(loader, tree);
    return loader.topNode;
  }

  //========================================================================================
  // Small Step Evaluation
  //========================================================================================

  /**
   * This acts like a hub to access the other small-step methods.
   * 
   * @param   ast The current AST node (can be a node or a value)
   * @return  Evaluated AST node
   */
  private Ast smallStepEval(Ast ast) {
    if (ast instanceof AstNode) {
      AstNode node = (AstNode) ast;
      
      switch (node.getLabel()) {
        case "assignment":
          return smallStepAssignmentEval(node);
        case "attribute":
          return smallStepAttributeEval(node);
        case "binop":
          return smallStepBinaryEval(node);
        case "case":
          return smallStepCaseEval(node);
        case "case_element":
          return smallStepCaseElementEval(node);
        case "class_decl":
          return smallStepClassDeclEval(node);
        case "class_def":
          return smallStepClassDefEval(node);
        case "defined_res_decl":
          return smallStepDefinedResDeclEval(node);
        case "defined_res_type":
          return smallStepDefinedResTypeEval(node);
        case "else":
          return smallStepElseEval(node);
        case "if":
          return smallStepIfEval(node);
        case "include":
          return smallStepIncludeEval(node);
        case "local_variable":
          return smallStepLocalVariableEval(node);
        case "program_elements":
          return smallStepSequentialProgramElementsEval(node);
        case "puppet_node":
          return smallStepPuppetNodeEval(node);
        case "qualified_variable":
          return smallStepQualifiedVariableEval(node);
        case "resource":
          return smallStepResourceEval(node);
        case "scope":
          return smallStepScopeEval(node);
        case "selector":
          return smallStepSelectorEval(node);
        case "selector_element":
          return smallStepSelectorElementEval(node);
        case "skip":
          return ast;
        case "statements":
          return smallStepStatementEval(node);
        case "unaryop":
          return smallStepUnaryEval(node);
        case "unless":
          return smallStepUnlessEval(node);
        default:
          System.err.println("Unknown label: " + node.getLabel());
          System.exit(1);
      }
    }

    return ast; /* this is an AstValue */
  }

  private Ast smallStepAssignmentEval(AstNode node) {
    /* first child is a variable, second child is an expression */
    String variableName = ((AstNode) node.getChild(0)).getName();
    node.setName(variableName);

    node.removeChild(0);
    printAstTree(node);
    
    evaluateChildren(node); /* step if it can */
    
    AstValue<?> rightSideOfAssignment = (AstValue<?>) node.getChild(0);
    
    customUpdateFunction(variableName, rightSideOfAssignment);

    convertToSkip(node);
    
    return node;
  }

  private Ast smallStepAttributeEval(AstNode node) {
    evaluateChildren(node); /* step child if it can */
    
    return node;
  }
  
  private Ast smallStepBinaryEval(AstNode node) {
    evaluateChildren(node); /* step through children if possible */
    
    AstValue<?> leftChild = (AstValue<?>) node.getChild(0);
    AstValue<?> rightChild = (AstValue<?>) node.getChild(1);

    String operator = node.getName();
    if ((operator.compareTo("and") == 0 || operator.compareTo("or") == 0)
        && leftChild instanceof AstValueBoolean 
        && rightChild instanceof AstValueBoolean) {
      /* operators that require both children to be boolean */
      boolean leftValue = ((AstValueBoolean) leftChild).getValue();
      boolean rightValue = ((AstValueBoolean) rightChild).getValue();

      switch (operator) {
        case "and":
          return valueFactoryObject.getValue(Boolean.toString(leftValue & rightValue));
        case "or":
          return valueFactoryObject.getValue(Boolean.toString(leftValue | rightValue));
      }
    } else if ((operator.compareTo("*") == 0 || operator.compareTo("/") == 0
        || operator.compareTo("%") == 0 || operator.compareTo("+") == 0
        || operator.compareTo("-") == 0 || operator.compareTo("<<") == 0
        || operator.compareTo(">>") == 0 || operator.compareTo("<") == 0
        || operator.compareTo(">") == 0 || operator.compareTo("<=") == 0
        || operator.compareTo(">=") == 0) && leftChild instanceof AstValueInt
        && rightChild instanceof AstValueInt) {
      /* operators that require both children to be integer */
      int leftValue = ((AstValueInt) leftChild).getValue();
      int rightValue = ((AstValueInt) rightChild).getValue();

      switch (operator) {
        case "*":
          return valueFactoryObject.getValue(Integer.toString(leftValue * rightValue));
        case "/":
          return valueFactoryObject.getValue(Integer.toString(leftValue / rightValue));
        case "%":
          return valueFactoryObject.getValue(Integer.toString(leftValue % rightValue));
        case "+":
          return valueFactoryObject.getValue(Integer.toString(leftValue + rightValue));
        case "-":
          return valueFactoryObject.getValue(Integer.toString(leftValue - rightValue));
        case "<<":
          return valueFactoryObject.getValue(Integer.toString(leftValue << rightValue));
        case ">>":
          return valueFactoryObject.getValue(Integer.toString(leftValue >> rightValue));
        case "<":
          return valueFactoryObject.getValue(Boolean.toString(leftValue < rightValue));
        case ">":
          return valueFactoryObject.getValue(Boolean.toString(leftValue > rightValue));
        case "<=":
          return valueFactoryObject.getValue(Boolean.toString(leftValue <= rightValue));
        case ">=":
          return valueFactoryObject.getValue(Boolean.toString(leftValue >= rightValue));
      }
    } else if (operator.compareTo("in") == 0 && leftChild instanceof AstValueString
        && rightChild instanceof AstValueString) {
      /* operators that require both children to be integer */
      String leftValue = ((AstValueString) leftChild).getValue();
      String rightValue = ((AstValueString) rightChild).getValue();

      boolean result = rightValue.toLowerCase().contains(leftValue.toLowerCase());
      return valueFactoryObject.getValue(Boolean.toString(result));
    }
    
    /* this will only be reached if previous conditions fail */
    System.err.print(operator + " cannot be performed on " + leftChild.getValue());
    System.err.println(" & " + rightChild.getValue());
    System.exit(1);
    return node;
  }

  private Ast smallStepCaseEval(AstNode node) {
    evaluateChildren(node);
    
    /* first element is the one being compared */
    AstValue<?> controlExpression = (AstValue<?>) node.getChild(0);
    String controlExpressionString = controlExpression.toString();
    node.setName(controlExpressionString);
    
    /* the rest are cases */
    node.removeChild(0);
    printAstTree(node);
    
    /* do all comparisons via Strings */
    for (int i = 0; i < node.getNumberOfChildren(); i++) {
      AstNode selectCase = (AstNode) node.getChild(i);
      
      if (controlExpressionString.compareTo(selectCase.getName()) == 0) {
        Ast statement = selectCase.getChild(0);
        
        node.emptyChildren();
        node.addChild(statement);
        printAstTree(node);
        
        evaluateChildren(node);
        
        if (node.getNumberOfChildren() == 0) {
          convertToSkip(node);
        }
        
        return node;
      } else {
        node.removeChild(i--);
        printAstTree(node);
      }
    }
    
    convertToSkip(node);
    
    return node;
  }
  
  private Ast smallStepCaseElementEval(AstNode node) {
    AstValue<?> selectCase = (AstValue<?>) smallStepEval(node.getChild(0));
    node.removeChild(0);
    
    /* convert all to string */
    String selectCaseString = selectCase.toString();
    
    node.setName(selectCaseString);
    printAstTree(node);
    
    return node;
  }
  
  private Ast smallStepClassDeclEval(AstNode node) {
    String defName = node.getName();
    
    if (!definitionEnvironment.containsKey(defName)) {
      System.err.println("The class does not exist: " + defName);
      System.exit(1);
    }
    
    Definition def = definitionEnvironment.get(defName);
    
    if (def instanceof ClassDef) {
      ClassDef classDef = (ClassDef) def;
      String parentName = classDef.getParentName();
      
      if (parentName != null) {        
        if (!definitionEnvironment.containsKey(parentName)) {
          System.err.println("The class does not exist: " + parentName);
          System.exit(1);
        }
        
        Definition parentDef = definitionEnvironment.get(parentName);
        
        /* create seq statements to include parent */
        if (parentDef instanceof ClassDef) {
          AstNode parentInclude = new AstNode("include", node);
          parentInclude.setName(parentName);
          
          AstNode selfInclude = (AstNode) node.clone();
          
          convertToSkip(node); /* just to clear the node */
          node.setLabel("statements");
          node.addChild(parentInclude);
          node.addChild(selfInclude);
          printAstTree(node);
          
          return smallStepEval(node);
        } else if (!(parentDef instanceof DeclaredClass)) {
          System.err.println("Parent definition is not a class: " + parentName);
          System.exit(1);
        }
      }
      
      /* step through all the attributes */
      evaluateChildren(node);
      
      Map<Variable, Ast> argumentsMap = generateArguments(node);
      Map<Variable, Ast> parametersMap = classDef.getParameters();
      Map<Variable, Ast> updatedParametersMap = customMergeFunction(parametersMap, argumentsMap);
      
      convertToSkip(node); /* just to clear the node */
      node.setLabel("scope");
      node.setName("::" + defName);
      
      for (Variable p : updatedParametersMap.keySet()) {
        if (updatedParametersMap.get(p) != null) {
          AstNode assignmentNode = new AstNode("assignment", node);
          
          AstNode variableNode = new AstNode("local_variable", node);
          variableNode.setName(p.getName());
          
          assignmentNode.addChild(variableNode);
          assignmentNode.addChild(updatedParametersMap.get(p));
          node.addChild(assignmentNode);
        } else {
          System.err.println("The parameter has no value: " + p.getName());
          System.exit(1);
        }
      }
      
      /* add the remaining statements on */
      for (Ast s : classDef.getStatements()) {
        node.addChild(s);
      }
      
      printAstTree(node);
      definitionEnvironment.put(defName, new DeclaredClass(parentName));
      
      smallStepEval(node);
    } else if (def instanceof DeclaredClass) {
      convertToSkip(node);
    } else {
      System.err.println("Cannot declare this as a class: " + defName);
      System.exit(1);
    }
    
    return node;
  }

  private Ast smallStepClassDefEval(AstNode node) {
    String currentNodeName = node.getName();

    if (definitionEnvironment.containsKey(currentNodeName)) {
      System.err.print("The name " + node.getName());
      System.err.println(" is already used");
      System.exit(1);
    }

    Map<Variable, Ast> parameterMap = generateParameters(node);

    String parentName = null;
    /* the child following the parameters may be an inherit */
    if (((AstNode) node.getChild(0)).getLabel().compareTo("inherits") == 0) {
      parentName = ((AstNode) node.getChild(0)).getName();
      node.removeChild(0);
    }
    
    definitionEnvironment.put(currentNodeName, new ClassDef(parentName, parameterMap, node.getChildren()));
    convertToSkip(node);
    return node;
  }

  private Ast smallStepDefinedResDeclEval(AstNode node) {
    String defName = node.getName();
    
    if (!definitionEnvironment.containsKey(defName)) {
      System.err.println("The resource definition does not exist: " + defName);
      System.exit(1);
    }
    
    Definition def = null;
    try {
      def = (Definition) definitionEnvironment.get(defName).clone();
    } catch (CloneNotSupportedException e) {
      System.err.println("Error when cloning: " + node.getName());
      System.exit(1);
    }
    
    if (!(def instanceof ResourceDef)) {
      System.err.println("The definition is not a resource definition: " + defName);
      System.exit(1);
    }
    
    ResourceDef resourceDef = (ResourceDef) def;
    
    /* step through all the attributes */
    evaluateChildren(node);
    
    node.removeChild(0); /* title has no current use */
    
    Map<Variable, Ast> argumentsMap = generateArguments(node);
    Map<Variable, Ast> parametersMap = resourceDef.getParameters();
    
    parametersMap = customMergeFunction(parametersMap, argumentsMap);
        
    convertToSkip(node); /* just to clear the node */
    node.setLabel("scope");
    node.setName("(" + currentScope.getName() + " " + defName + ")");
    node.setType("alpha_def");
    
    for (Variable p : parametersMap.keySet()) {
      AstNode assignmentNode = new AstNode("assignment", node);
        
      AstNode variableNode = new AstNode("local_variable", node);
      variableNode.setName(p.getName());
        
      assignmentNode.addChild(variableNode);
      assignmentNode.addChild(parametersMap.get(p));
      node.addChild(assignmentNode);
    }
    
    /* add the remaining statements on */
    for (Ast s : resourceDef.getStatements()) {
      node.addChild((Ast) ((AstNode) s).clone());
    }
    
    printAstTree(node);
    
    smallStepEval(node);
    
    return node;
  }
  
  private Ast smallStepDefinedResTypeEval(AstNode node) {
    String defName = node.getName();
    
    if (definitionEnvironment.containsKey(defName)) {
      System.err.print("The name " + node.getName());
      System.err.println(" is already used");
      System.exit(1);
    }
    
    Map<Variable, Ast> parameterMap = generateParameters(node);
    
    definitionEnvironment.put(defName, new ResourceDef(parameterMap, node.getChildren()));
    convertToSkip(node);
    return node;
  }
  
  private Ast smallStepElseEval(AstNode node) {
    evaluateChildren(node); 
    
    if (node.getNumberOfChildren() == 0) {
      convertToSkip(node);
      printAstTree(node);
    }
    
    return node;
  }
  
  private Ast smallStepIfEval(AstNode node) {
    Ast conditionExpression = node.getChild(0);
    if (conditionExpression instanceof AstNode) { /* the condition expression can step */
      conditionExpression = smallStepEval(conditionExpression);
      node.replaceChild(conditionExpression, 0);
      printAstTree(node);
    }
    
    if (!(conditionExpression instanceof AstValueBoolean)) {
      System.err.println("The condition for an 'if' must be a boolean");
      System.exit(1);      
    }
    
    boolean condition = ((AstValueBoolean) conditionExpression).getValue();
    
    node.setName(Boolean.toString(condition));
    node.removeChild(0);
    printAstTree(node);
    
    if (condition) {
      if (node.getNumberOfChildren() > 1) {
        node.removeChild(1);
        printAstTree(node);
      }
      
      AstNode evaluatedNode = (AstNode) smallStepEval(node.getChild(0));
      
      if (evaluatedNode.getLabel().compareTo("skip") == 0) {
        node.removeChild(0);
        printAstTree(node);
        convertToSkip(node);
      }
    } else {
      if (node.getNumberOfChildren() > 1) {
        node.removeChild(0);
        printAstTree(node);
        
        AstNode evaluatedNode = (AstNode) smallStepEval(node.getChild(0));
        
        if (evaluatedNode.getLabel().compareTo("skip") == 0) {
          node.removeChild(0);
          printAstTree(node);
          convertToSkip(node);
        }
      } else {
        convertToSkip(node);
      }
    }
    
    return node;
  }
  
  private Ast smallStepIncludeEval(AstNode node) {
    String defName = node.getName();

    if (!definitionEnvironment.containsKey(defName)) {
      System.err.println("The included class does not exist: " + defName);
      System.exit(1);
    }

    Definition def = definitionEnvironment.get(defName);
    
    if (def instanceof ClassDef) {
      ClassDef classDef = (ClassDef) def;
      
      String parentName = classDef.getParentName();
      if (parentName != null) {
        if (!definitionEnvironment.containsKey(parentName)) {
          System.err.println("The class does not exist: " + parentName);
          System.exit(1);
        }
        
        Definition parentDef = definitionEnvironment.get(parentName);
        
        if (parentDef instanceof ClassDef) {
          /* create two include nodes and attach to current node */
          AstNode parentInclude = new AstNode("include", node);
          parentInclude.setName(parentName);
          
          AstNode selfInclude = new AstNode("include", node);
          selfInclude.setName(node.getName());
          
          convertToSkip(node); /* just to clear the node */
          node.setLabel("statements");
          node.addChild(parentInclude);
          node.addChild(selfInclude);
          printAstTree(node);
          
          return smallStepEval(node);
        } else if (!(parentDef instanceof DeclaredClass)) {
          System.err.println("Parent definition is not a class: " + parentName);
          System.exit(1);
        }
      }

      definitionEnvironment.put(defName, new DeclaredClass(parentName));
      
      convertToSkip(node); /* just to clear the node */
      node.setLabel("scope");
      node.setName("::" + defName);
      
      Map<Variable, Ast> currentParameters = classDef.getParameters();
      
      for (Variable p : currentParameters.keySet()) {
        if (currentParameters.get(p) != null) {
          /* create an assignment node for each parameter */
          AstNode assignmentNode = new AstNode("assignment", node);
          
          AstNode variableNode = new AstNode("local_variable", node);
          variableNode.setName(p.getName());
          
          assignmentNode.addChild(variableNode);
          assignmentNode.addChild(currentParameters.get(p));
          node.addChild(assignmentNode);
        }
      }
      
      /* add the remaining statements on */
      for (Ast s : classDef.getStatements()) {
        node.addChild(s);
      }
      
      printAstTree(node);
      
      smallStepEval(node);
    } else if (def instanceof DeclaredClass) {
      convertToSkip(node);
    } else {
      System.err.println("Definition is not a class: " + defName);
      System.exit(1);
    }
    
    return node;
  }

  private Ast smallStepLocalVariableEval(AstNode node) {
    Variable currentVariable = new Variable(node.getName());

    String scopeIterator = currentScope.getName();

    while (scopeIterator != null) {
      String scopeName = scopeIterator;
      
      String variableName = currentVariable.getName();

      KeyPair currentKey = new KeyPair (scopeName, variableName);
      
      if (store.containsKey(currentKey)) {
        return store.get(currentKey);
      } else {
        /* this is just to remove the "::" in the name */
        String unScopedName = scopeName.replaceFirst("::", "");
        
        if (definitionEnvironment.containsKey(unScopedName)) {
          scopeIterator = "::" + definitionEnvironment.get(unScopedName).getParentName();
        } else if (scopeIterator.compareTo("::") != 0) { /* if inside a node */
          scopeIterator = "::";
        } else {
          scopeIterator = null;
        }
      }
    }

    System.err.print("The variable does not have a value: ");
    System.err.println(currentVariable.getName());
    System.exit(1);
    
    return node;
  }

  private Ast smallStepPuppetNodeEval(AstNode node) {    
    node.setLabel("scope");
    node.setName("::" + node.getName());
    
    printAstTree(node);
    
    return smallStepEval(node);
  }
  
  private Ast smallStepQualifiedVariableEval(AstNode node) {
    Variable currentVariable = new Variable(node.getName());
    
    String variableName = currentVariable.getName();
    int indexOfName = variableName.lastIndexOf(':');
    
    String scopeName = variableName.substring(0, indexOfName - 1);
    
    if (scopeName.compareTo("") == 0) {
      scopeName = "::"; /* assign top scope */
    }
    
    variableName = variableName.substring(indexOfName + 1);
    
    KeyPair currentKey = new KeyPair(scopeName, variableName);
    
    if (store.containsKey(currentKey)) {
      return store.get(currentKey);
    } else {
      System.err.print("The variable does not have a value: ");
      System.err.println(currentKey);
      System.exit(1);
    }
    
    return node;
  }

  private Ast smallStepResourceEval(AstNode node) {
    String resourceType = node.getType();
    String resourceName = "";
    
    evaluateChildren(node); /* see if the child can step */
    
    AstValue<?> resourceTitle = (AstValue<?>) node.getChild(0);
    
    if (resourceTitle instanceof AstValueString) {
      resourceName = ((AstValueString) resourceTitle).getValue();
      node.removeChild(0);
      node.setName(resourceName);
      printAstTree(node);
    } else {
      System.err.println("Resource name must be a String");
      System.exit(1);
    }

    Resource currentResource = new Resource(resourceName, resourceType);

    currentResource.updateAttributes(node);

    String resourceMapKey = resourceType + ":" + resourceName;

    if (resourceMap.containsKey(resourceMapKey)) {
      System.err.print("The resource of type " + resourceType + " and name " + resourceName);
      System.err.println(" already exists");
      System.exit(1);
    } else {
      resourceMap.put(resourceMapKey, currentResource);
    }

    if (catalog.compareTo("") != 0) {
      catalog += ",\n";
    }

    catalog += currentResource.toString();
    
    convertToSkip(node);

    return node;
  }

  private Ast smallStepScopeEval(AstNode node) {
    Scope newScope = new Scope(node.getName(), currentScope);
    currentScope = newScope;
    
    evaluateChildren(node);
    
    if (node.getType().compareTo("alpha_def") == 0) {
      customClearFunction(node.getName());
    }
    
    currentScope = currentScope.getPreviousScope();
    
    if (node.getNumberOfChildren() == 0) {
      convertToSkip(node);
    }
    
    return node;
  }
  
  private Ast smallStepSelectorEval(AstNode node) {
    evaluateChildren(node);
    
    /* first element is the one being compared */
    AstValue<?> controlExpression = (AstValue<?>) node.getChild(0);
    String controlExpressionString = controlExpression.toString();
    node.setName(controlExpressionString);
    
    /* the rest are cases */
    node.removeChild(0);
    printAstTree(node);
    
    /* do all comparisons via Strings */
    for (int i = 0; i < node.getNumberOfChildren(); i++) {
      AstNode selectCase = (AstNode) node.getChild(i);
      
      /* move default to the end */
      if (selectCase.getName().compareTo("default") == 0) {
        if (i != node.getNumberOfChildren() - 1) {
          node.removeChild(i--);
          node.addChild(selectCase);
          printAstTree(node);
        } else {
          Ast statement = selectCase.getChild(0);
          
          node.emptyChildren();
          node.addChild(statement);
          printAstTree(node);
          
          return smallStepEval(statement);
        }
      } else {
        if (controlExpressionString.compareTo(selectCase.getName()) == 0) {
          Ast statement = selectCase.getChild(0);
          
          node.emptyChildren();
          node.addChild(statement);
          printAstTree(node);
          
          return smallStepEval(statement);
        } else {
          node.removeChild(i--);
          printAstTree(node);
        }
      }
    }
    
    convertToSkip(node);
    
    return node;
  }
  
  private Ast smallStepSelectorElementEval(AstNode node) {    
    /* this indicates that it is not the default node */
    if (node.getNumberOfChildren() > 1) {
      AstValue<?> selectCase = (AstValue<?>) smallStepEval(node.getChild(0));
      node.removeChild(0);
      
      /* convert all to string */
      String selectCaseString = selectCase.toString();
      
      /* assure a non-default case is not default */
      if (selectCaseString.compareTo("default") != 0) {
        node.setName(selectCaseString);
        printAstTree(node);
      } else {
        System.err.println("Non-default cases cannot be named default");
        System.exit(1);
      }
    }
    
    return node;
  }
  
  private Ast smallStepSequentialProgramElementsEval(AstNode node) {
    currentScope = new Scope("::", null); /* top-level scope */

    Ast defaultNode = null;

    for (int i = 0; i < node.getNumberOfChildren(); i++) {
      AstNode child = (AstNode) node.getChild(i);

      String currentChildLabel = child.getLabel();
      String currentChildName = child.getName();

      switch (currentChildLabel) {
        case "puppet_node":
          if (currentChildName.compareTo("default") == 0) { /* take note of default node */
            defaultNode = child;
            System.out.println("moving the default node to the end");
          } else {
            convertToSkip(child);
            printAstTree(node);                      
          }
          
          node.removeChild(i--);
          printAstTree(node);

          break;
        default:
          smallStepEval(child); /* step through child */
          if (child.getLabel().compareTo("skip") == 0) {
            printAstTree(node);
            node.removeChild(i--);
            printAstTree(node);
          }
      }
    }

    /* evaluate default node */
    if (defaultNode != null) {
      node.addChild(defaultNode);
      printAstTree(node);      
      smallStepEval(defaultNode);
    } else if (definitionEnvironment.containsKey("main")) {
      /* set up a default node with an include main */
      AstNode customDefaultNode = new AstNode("puppet_node", node);
      customDefaultNode.setName("default");

      AstNode tempNode = new AstNode("include", customDefaultNode);
      tempNode.setName("main");
      
      node.addChild(customDefaultNode);
      customDefaultNode.addChild(tempNode);
      printAstTree(node);
      smallStepEval(customDefaultNode);
    }
    
    return node;
  }

  private Ast smallStepStatementEval(AstNode node) {
    evaluateChildren(node);
    
    if (node.getNumberOfChildren() == 0) {
      convertToSkip(node);
    }
    
    return node;
  }

  private Ast smallStepUnaryEval(AstNode node) {
    evaluateChildren(node); /* step through child if possible */
    
    AstValue<?> valueChild = (AstValue<?>) node.getChild(0);

    /* update tree by replacing unary operator with value */
    if (valueChild instanceof AstValueBoolean) {
      boolean value = ((AstValueBoolean) valueChild).getValue();
      return valueFactoryObject.getValue(Boolean.toString(!value));
    } else {
      System.err.println("The value cannot be negated: " + valueChild.getValue());
      System.exit(1);
    }

    return node;
  }

  private Ast smallStepUnlessEval(AstNode node) {
    Ast conditionExpression = node.getChild(0);
    if (conditionExpression instanceof AstNode) { /* the condition expression can step */
      conditionExpression = smallStepEval(conditionExpression);
      node.replaceChild(conditionExpression, 0);
      printAstTree(node);
    }
    
    if (!(conditionExpression instanceof AstValueBoolean)) {
      System.err.println("The condition for an 'if' must be a boolean");
      System.exit(1);      
    }
    
    boolean condition = ((AstValueBoolean) conditionExpression).getValue();
    
    node.setName(Boolean.toString(condition));
    node.removeChild(0);
    printAstTree(node);
    
    if (!condition) {
      evaluateChildren(node);
      
      if (node.getNumberOfChildren() == 0) {
        convertToSkip(node);
        printAstTree(node);
      }
    } else {
      convertToSkip(node);
    }
    
    return node;
  }
  
  //========================================================================================
  // Misc
  //========================================================================================

  /**
   * This method is used to evaluate AST nodes in batches.
   * 
   * @param   node  This node's children are evaluated
   * @return  The node after it's children are evaluated
   */
  private Ast evaluateChildren(AstNode node) {
    for (int i = 0; i < node.getNumberOfChildren(); i++) {
      if (node.getChild(i) instanceof AstNode) {
        AstNode child = (AstNode) node.getChild(i);
        Ast evaluedNode = smallStepEval(child);

        if (evaluedNode instanceof AstValue) {
          node.replaceChild(evaluedNode, i);
          printAstTree(node);
        } else if (((AstNode) evaluedNode).getLabel().compareTo("skip") == 0) {
          printAstTree(node);
          node.removeChild(i--);
          printAstTree(node);
        }
      }
    }

    return node;
  }

  /**
   * Converts the current node into a 'skip' node.
   * 
   * @param   node  The node being converted
   */
  private void convertToSkip(AstNode node) {
    node.setLabel("skip");
    node.setName("");
    node.emptyChildren();
  }
  
  /**
   * Generates the parameters for a definition.
   * 
   * @param   node  The node in question
   * @return  Map containing the parameters
   */
  private Map<Variable, Ast> generateParameters(AstNode node) {
    Map<Variable, Ast> parameterMap = new HashMap<Variable, Ast>();
    
    /* parameters are the first set of children */
    for (int i = 0; i < node.getNumberOfChildren(); i++) {
      AstNode child = (AstNode) node.getChild(i);
      
      if (child.getLabel().compareTo("parameter") == 0) {
        Ast parameterLeftSide = child.getChild(0);

        Ast parameterRightSide = null;
        if (child.getNumberOfChildren() > 1) {
          parameterRightSide = child.getChild(1);
        }

        Variable parameterVariable = new Variable(((AstNode) parameterLeftSide).getName());

        parameterMap.put(parameterVariable, parameterRightSide);

        node.removeChild(i--);
      } else {
        break;
      }
    }
    
    return parameterMap;
  }
  
  /**
   * Generates the arguments for a declaration.
   * 
   * @param   node  The declaration
   * @return  The map containing the arguments
   */
  private Map<Variable, Ast> generateArguments(AstNode node) {
    Map<Variable, Ast> argumentMap = new HashMap<Variable, Ast>();
    
    /* parameters are the first set of children */
    for (int i = 0; i < node.getNumberOfChildren(); i++) {
      AstNode child = (AstNode) node.getChild(i);
      
      if (child.getLabel().compareTo("attribute") == 0) {
        Variable argumentVariable = new Variable(child.getName());

        Ast argumentValue = child.getChild(0);

        argumentMap.put(argumentVariable, argumentValue);

        node.removeChild(i--);
      } else {
        break;
      }
    }
    
    return argumentMap;
  }
  
  /**
   * Will take a map of parameters and a map of arguments.
   * The arguments overwrite the default value (if any) the
   * named parameter. An error will be thrown if any of the
   * arguments call parameters that don't exist or if there
   * are parameters with no default values.
   * 
   * @param   parameterMap  The map of parameters
   * @param   argumentMap   The map of arguments
   * @return  The updated (in defaults) parameter map
   */
  private Map<Variable, Ast> customMergeFunction(Map<Variable, Ast> parameterMap, Map<Variable, Ast> argumentMap) {
    /* apply arguments to relevant parameters */
    for (Variable p : argumentMap.keySet()) {
      if (customLookupFunction(p, parameterMap)) {
        parameterMap.put(p, argumentMap.get(p));
      } else {
        System.err.println("Parameter is missing: " + p.getName());
        System.exit(1);
      }
    }
    
    /* check that all parameters have a value */
    for (Variable a : parameterMap.keySet()) {
      if (!customLookupFunction(a, argumentMap) && parameterMap.get(a) == null) {
        System.err.println("Argument is missing: " + a.getName());
        System.exit(1);
      }
    }
    
    return parameterMap;
  }
  
  /**
   * This method looks for a certain variable in a map.
   * 
   * @param   p             The parameter
   * @param   parameterMap  The map
   * @return  Returns true if p is in the map, else false
   */
  private boolean customLookupFunction(Variable p, Map<Variable, Ast> parameterMap) {
    return parameterMap.containsKey(p);
  }
  
  /**
   * Removes all items in the store with a given scope.
   * 
   * @param defName  The scope in question
   */
  private void customClearFunction(String defName) {
    Iterator<Entry<KeyPair, AstValue<?>>> iter = store.entrySet().iterator();
    while (iter.hasNext()) {
       KeyPair key = iter.next().getKey();
       if (key.getScopeName().compareTo(defName) == 0) {
         iter.remove();
      }
    }
  }
  
  /**
   * Attempts to add an item to the store. An error arises if the
   * item already exists in the store.
   * 
   * @param   variableName  The Name of the variable
   * @param   currentValue  The value of the variable
   */
  private void customUpdateFunction(String variableName, AstValue<?> currentValue) {
    KeyPair currentKey = new KeyPair(currentScope.getName(), variableName);
    
    /* check that the current (scope, variable-name) is not already in the store */
    if (store.containsKey(currentKey)) {
      System.err.println("Cannot reassign variable: " + currentKey);
      System.exit(1);
    } else {
      store.put(currentKey, currentValue);
    }
  }
  
  //========================================================================================
  // Printing
  //========================================================================================

  /**
   * Top level of printing the AST. Given a node, the top node will be found
   * by following the parent links all the way up.
   * 
   * @param   astTree   A node
   */
  private void printAstTree(Ast astTree) {
    AstNode topNode = (AstNode) astTree;
    while (topNode.getParent() != null) {
      topNode = topNode.getParent();
    }

    printAstTree(topNode, 0);
    
    for (int i = 0; i < 20; i++) {
      System.out.print("=");
    }
    System.out.print("\n");
  }

  /**
   * Recursive call to print all nodes in the current Tree.
   * 
   * @param   astTree   The current node
   * @param   level     Level dictates the amount of \t used prior
   */
  private void printAstTree(Ast astTree, int level) {
    for (int i = 0; i < level; i++) {
      System.out.print("   ");
    }

    if (astTree instanceof AstValue) {
      System.out.println(((AstValue<?>) astTree).getValue());
    } else {
      AstNode currentNode = (AstNode) astTree;
      System.out.print(currentNode.getLabel());

      if (currentNode.getName().compareTo("") == 0) {
        System.out.println();
      } else {
        System.out.println(" - " + currentNode.getName());
      }

      for (Ast child : currentNode.getChildren()) {
        printAstTree(child, level + 1);
      }
    }
  }

  /**
   * Writes the catalog to an file.
   * 
   * @param   inputFileName   The filename will altered into the output filename
   */
  private void outputCatalog(String inputFileName) {
    /* using user input to name output */
    String outputFileName = inputFileName.split("\\.")[0];

    int t1 = outputFileName.split("\\\\").length;
    if (t1 > 1) {
      outputFileName = outputFileName.split("\\\\")[t1 - 1];
    }

    t1 = outputFileName.split("/").length;
    if (t1 > 1) {
      outputFileName = outputFileName.split("/")[t1 - 1];
    }

    outputFileName = "output_catalogs/" + outputFileName + "_catalog.log";
    
    File f = new File(outputFileName);
    
    try {
      Files.deleteIfExists(f.toPath());
    } catch (IOException e1) {
      System.err.println("Error in deleting existing catalog txt file");
      System.err.println(f.toPath());
      System.exit(1);
    }

    PrintWriter outputWriter = null;
    try {
      outputWriter = new PrintWriter(outputFileName, "UTF-8");
    } catch (Exception e) {
      System.err.println("Something went wrong in setting up the output writer");
      System.exit(1);
    }

    if (catalog.compareTo("") == 0) {
      outputWriter.println("[]");
    } else {
      outputWriter.println(catalog);
    }

    outputWriter.close();
  }
  
  //========================================================================================
  // 
  //========================================================================================
}